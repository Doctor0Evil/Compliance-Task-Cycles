package bithub.cache

default ok = false

ok {
  # require at least one cache path and one artifact mapping per matrix entry
  some i
  m := input[".bit/build.art.create.yml"].build.matrix[i]
  count(m.cache_paths) > 0
  count(m.artifacts) > 0
}

deny[msg] {
  not ok
  msg := "Bit.Hub: build.art.create must define cache_paths and artifacts for every entry"
}
runner:
  id: "aln://bitrunners/phoenix/default"
  version: "1.0.0"
  personas: ["strict","hybrid"]
  capabilities:
    langs: ["node18","python3.11","java17","dotnet6"]
    build: ["pack","test","bundle"]
    artifacts: ["tar.gz","zip"]
  policies:
    dir: ".bithub/policies"
    enforce_strict: true
  cache:
    primary: "actions-cache"
    secondary:
      enabled: true
      driver: "ns"          # ns | s3 | ipfs
      ns_roots: [".bithub/cache"]
      s3_bucket: ""         # if driver == s3
      s3_region: "us-west-2"
      ipfs_gateway: "https://ipfs.io"
    keys:
      salt: "v1"            # bump to invalidate globally
  ledger:
    path: ".bithub/ledger/runner.log"
build:
  matrix:
    - id: "node"
      lang: "node"
      install: "npm ci"
      build: "npm run build"
      cache_paths: ["~/.npm","node_modules"]
      cache_files: ["package-lock.json","packages/*/package-lock.json"]
      artifacts:
        - path: "dist/**"
          name: "web-dist"
    - id: "python"
      lang: "python"
      install: "pip install -r requirements.txt"
      build: "pytest -q"
      cache_paths: ["~/.cache/pip"]
      cache_files: ["requirements.txt","requirements.lock"]
      artifacts:
        - path: "reports/**"
          name: "test-reports"
    - id: "dotnet"
      lang: "dotnet"
      setup: "dotnet --info"
      install: "dotnet restore"
      build: "dotnet build --configuration Release"
      cache_paths: ["~/.nuget/packages"]
      cache_files: ["**/packages.lock.json","**/*.csproj","**/*.sln"]
      artifacts:
        - path: "**/bin/Release/**"
          name: "dotnet-release"
    - id: "java"
      lang: "java"
      install: "mvn -q -B -DskipTests dependency:go-offline"
      build: "mvn -q -B package"
      cache_paths: ["~/.m2/repository"]
      cache_files: ["pom.xml","**/pom.xml"]
      artifacts:
        - path: "**/target/*.jar"
          name: "maven-jars"
artifacts:
  retention_days: 7
#!/usr/bin/env bash
set -euo pipefail
MANIFEST=".bit/bitrunners.manifest.yml"
LEDGER=$(yq '.runner.ledger.path' "$MANIFEST")
mkdir -p "$(dirname "$LEDGER")"
echo "{\"ts\":\"$(date -Iseconds)\",\"event\":\"BOOT\",\"runner\":\"$(yq '.runner.id' "$MANIFEST")\"}" >> "$LEDGER"

# Start OPA server with policies (optional headless use)
if command -v opa >/dev/null; then
  opa run --server --addr :8181 "$(yq '.runner.policies.dir' "$MANIFEST")" >/dev/null 2>&1 &
  echo "{\"ts\":\"$(date -Iseconds)\",\"event\":\"OPA_START\",\"port\":8181}" >> "$LEDGER"
fi

# Prewarm cache
if .bit/loaders/cache_prewarm.sh; then
  echo "{\"ts\":\"$(date -Iseconds)\",\"event\":\"CACHE_PREWARM_OK\"}" >> "$LEDGER"
else
  echo "{\"ts\":\"$(date -Iseconds)\",\"event\":\"CACHE_PREWARM_SKIP_OR_FAIL\"}" >> "$LEDGER"
fi
#!/usr/bin/env bash
set -euo pipefail
MANIFEST=".bit/bitrunners.manifest.yml"
SECONDARY_ENABLED=$(yq '.runner.cache.secondary.enabled' "$MANIFEST")
[[ "$SECONDARY_ENABLED" != "true" ]] && exit 0

ROOT=".bithub/cache"
mkdir -p "$ROOT"
# Restore language tarballs if present (ns driver)
for t in node.tgz python.tgz dotnet.tgz java.tgz; do
  [[ -f "$ROOT/$t" ]] || continue
  case "$t" in
    node.tgz)   mkdir -p ~/.npm node_modules; tar -xzf "$ROOT/$t" -C . ;;
    python.tgz) mkdir -p ~/.cache/pip;        tar -xzf "$ROOT/$t" -C . ;;
    dotnet.tgz) mkdir -p ~/.nuget/packages;   tar -xzf "$ROOT/$t" -C . ;;
    java.tgz)   mkdir -p ~/.m2/repository;    tar -xzf "$ROOT/$t" -C . ;;
  esac
done
name: "Bit.Hub Cache Keys"
description: "Compute portable cache keys and paths from build.art.create.yml"
inputs:
  lang:
    required: true
  cache-files:
    required: true
  cache-paths:
    required: true
  salt:
    required: false
    default: "v1"
outputs:
  key:
    value: ${{ steps.mk.outputs.key }}
  restore-keys:
    value: ${{ steps.mk.outputs.restore }}
  path:
    value: ${{ steps.mk.outputs.path }}
runs:
  using: "composite"
  steps:
    - id: mk
      shell: bash
      run: |
        set -euo pipefail
        CF="${{ inputs.cache-files }}"
        CP="${{ inputs.cache-paths }}"
        SALT="${{ inputs.salt }}"
        LANG="${{ inputs.lang }}"
        # Build restore key prefix and primary key with file hashes
        HASH="${{ hashFiles(format('{0}', inputs.cache-files)) }}"
        PREFIX="bithub-${LANG}-${{ runner.os }}-${SALT}-"
        echo "key=${PREFIX}${HASH}" >> "$GITHUB_OUTPUT"
        echo "restore=${PREFIX}" >> "$GITHUB_OUTPUT"
        # Convert multiline paths to single list
        P=$(echo "$CP" | tr '\n' '\n')
        echo "path=$P" >> "$GITHUB_OUTPUT"
name: "Bit.Hub Cache Keys"
description: "Compute portable cache keys and paths from build.art.create.yml"
inputs:
  lang:
    required: true
  cache-files:
    required: true
  cache-paths:
    required: true
  salt:
    required: false
    default: "v1"
outputs:
  key:
    value: ${{ steps.mk.outputs.key }}
  restore-keys:
    value: ${{ steps.mk.outputs.restore }}
  path:
    value: ${{ steps.mk.outputs.path }}
runs:
  using: "composite"
  steps:
    - id: mk
      shell: bash
      run: |
        set -euo pipefail
        CF="${{ inputs.cache-files }}"
        CP="${{ inputs.cache-paths }}"
        SALT="${{ inputs.salt }}"
        LANG="${{ inputs.lang }}"
        # Build restore key prefix and primary key with file hashes
        HASH="${{ hashFiles(format('{0}', inputs.cache-files)) }}"
        PREFIX="bithub-${LANG}-${{ runner.os }}-${SALT}-"
        echo "key=${PREFIX}${HASH}" >> "$GITHUB_OUTPUT"
        echo "restore=${PREFIX}" >> "$GITHUB_OUTPUT"
        # Convert multiline paths to single list
        P=$(echo "$CP" | tr '\n' '\n')
        echo "path=$P" >> "$GITHUB_OUTPUT"
